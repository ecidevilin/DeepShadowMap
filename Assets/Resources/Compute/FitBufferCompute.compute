
#pragma kernel KernelFitDeepShadowMap
#include "../Include/DeepShadowMap.cginc"

StructuredBuffer<DoublyLinkedNode> DoublyLinkedList;
RWStructuredBuffer<FittingFunc> FittingFuncList;

[numthreads(8,8,1)]
void KernelFitDeepShadowMap(uint3 id : SV_DispatchThreadID)
{
	if (id.y > Dimension - 1 || id.x > Dimension - 1)
	{
		return;
	}
	FittingFunc func = (FittingFunc)0;
	int offset = (id.y * Dimension + id.x) * NUM_BUF_ELEMENTS;
	if (DoublyLinkedList[offset].depth == 1)
	{
		func.f[0] = float3(0, 1, 1);
		FittingFuncList[offset] = func;
		return;
	}


	int current = offset;
	uint numElems = 1;
	DoublyLinkedNode node = DoublyLinkedList[current];;
	DoublyLinkedNode nodeNext;
	float maxDelta = 0;
	uint maxDeltaIdx = 0;

	float sumXY = 0;
	float sumX = 0;
	float sumY = 0;
	float sumXX = 0;
	int idx = offset;
	uint i = 0;

	float3 f[4];

	for (uint k = 0; k < 4; k++)
	{
		uint n = FittingBins[k];
		for (i = 0; i < n; i++)
		{
			DoublyLinkedNode node = DoublyLinkedList[idx++];
			float x = (float)i / n;
			float y = node.depth;
			sumXY += x * y;
			sumX += x;
			sumY += y;
			sumXX += x * x;
		}
		f[k].x = (n * sumXX - sumX * sumX) / (n * sumXY - sumX * sumY); //Reciprocal
		f[k].y = sumY / n - f[k].x * sumX / n;
		f[k].z = DoublyLinkedList[offset].depth;
		offset += n;
	}

	func.f = f;
	FittingFuncList[id.y * Dimension + id.x] = func;
}
