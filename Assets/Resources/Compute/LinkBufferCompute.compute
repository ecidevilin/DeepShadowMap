// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelLinkDeepShadowMap

#include "../Include/DeepShadowMap.cginc"
//StructuredBuffer<HeaderNode> HeaderList;
StructuredBuffer<DoublyLinkedNode> DoublyLinkedList;
RWStructuredBuffer<NeighborsNode> NeighborsList;


[numthreads(8,8,1)]
void KernelLinkDeepShadowMap(uint3 id : SV_DispatchThreadID)
{
	if (id.y > Dimension - 1 || id.x > Dimension - 1)
	{
		return;
	}

    int offset = (id.y * Dimension + id.x) * NUM_BUF_ELEMENTS;
	if (DoublyLinkedList[offset].shading == 0)
	{
		return;
	}
	// Center
	int currentCenter = offset;
	int currentRight, currentTop;
    DoublyLinkedNode currentEntryRight; 
    DoublyLinkedNode currentEntryTop;
	// Right x + 1
	if (id.x != Dimension - 1)
	{
		currentRight = offset + NUM_BUF_ELEMENTS;
        currentEntryRight = DoublyLinkedList[currentRight];
        if (currentEntryRight.shading == 0)
        {
            currentRight = -1;
        }
	}
	else
	{
		currentRight = -1;
	}
	// Top y + 1
	if (id.y != Dimension - 1)
	{
		currentTop = offset + NUM_BUF_ELEMENTS * Dimension;
        currentEntryTop = DoublyLinkedList[currentTop];
        if (currentEntryTop.shading == 0)
        {
            currentTop = -1;
        }
	}
	else
	{
		currentTop = -1;
	}

	DoublyLinkedNode tempListEntry;
    
	float depth;
	int i,j;
	for (i = 0; i < NUM_BUF_ELEMENTS; i++)
	{
		depth = DoublyLinkedList[currentCenter].depth;
		// Search Right
		for (j = 1; j < NUM_BUF_ELEMENTS; j++)
		{
			if (currentRight == -1 || currentEntryRight.shading == 0)
			{
				currentRight = -1;
				break;
			}
			tempListEntry = DoublyLinkedList[currentRight + 1];

            if(depth < tempListEntry.depth)
				break;
			currentRight++;
			currentEntryRight = tempListEntry;
		}
        if (j == NUM_BUF_ELEMENTS)
        {
            currentRight = -1;
        }
		
		NeighborsList[currentCenter].right = currentRight;
		
		// Search Top
		for(j = 1; j < NUM_BUF_ELEMENTS; j++)
		{
			if (currentTop == -1 || currentEntryTop.shading == 0)
			{
				currentTop = -1;
				break;
			}
			tempListEntry = DoublyLinkedList[currentTop + 1];
            if(depth < tempListEntry.depth)
				break;
			currentTop++;
			currentEntryTop = tempListEntry;
		}
        if (j == NUM_BUF_ELEMENTS)
        {
            currentTop = -1;
        }
		NeighborsList[currentCenter].top = currentTop;
		
		// Next
		currentCenter++;
		if(DoublyLinkedList[currentCenter].shading == 0)
			break;
	}
}