// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelResetTestResult
#pragma kernel KernelTestHeaderList
#pragma kernel KernelTestLinkedList
#pragma kernel KernelTestDoublyLinkedList
#pragma kernel KernelTestNeighborsList
#include "../Include/DeepShadowMap.cginc"

StructuredBuffer<HeaderNode> HeaderList;
StructuredBuffer<DoublyLinkedNode> DoublyLinkedList;
StructuredBuffer<LinkedNode> LinkedList;
RWStructuredBuffer<NeighborsNode> NeighborsList;
RWTexture2D<float4> TestRt;
int TestIndex;

[numthreads(8,8,1)]
void KernelResetTestResult(uint3 id : SV_DispatchThreadID)
{
    TestRt[id.xy] = float4(0,0,0,1);
}

[numthreads(8,8,1)]
void KernelTestHeaderList(uint3 id : SV_DispatchThreadID)
{
    int start = HeaderList[id.y * Dimension + id.x].start;
    if (start == -1)
    {
        TestRt[id.xy] = float4(0,0,0,1);
    }
    else
    {
        TestRt[id.xy] = float4(1,0,0,1);
    }
}

[numthreads(8,8,1)]
void KernelTestLinkedList(uint3 id : SV_DispatchThreadID)
{

    int start = HeaderList[id.y * Dimension + id.x].start;
    if (start == -1)
    {
        TestRt[id.xy] = float4(0, 0, 0, 1);
        return;
    }
    LinkedNode currentXEntry = LinkedList[start];
    int i = 1;
    for (;i < TestIndex; i++)
    {
        if (currentXEntry.next == -1)
        {
            TestRt[id.xy] = float4(0, 0, 0, 1);
            return;
        }
        currentXEntry = LinkedList[currentXEntry.next];
    }
    TestRt[id.xy] = float4(currentXEntry.depth, 0, currentXEntry.alpha, 1);
}

[numthreads(8,8,1)]
void KernelTestDoublyLinkedList(uint3 id : SV_DispatchThreadID)
{
	int offset = NUM_BUF_ELEMENTS * (id.y * Dimension + id.x);
	int i = 0;
	DoublyLinkedNode currentXEntry;
	do
	{
		currentXEntry = DoublyLinkedList[offset++];
		if (currentXEntry.headOrTail == -1)
		{
			TestRt[id.xy] = float4(0, 0, 1, 1);
			return;
		}
		i++;
	} while (i < TestIndex);
	TestRt[id.xy] = float4(currentXEntry.depth, currentXEntry.shading, currentXEntry.headOrTail, 1);
}

[numthreads(8,8,1)]
void KernelTestNeighborsList(uint3 id : SV_DispatchThreadID)
{
	int offset = NUM_BUF_ELEMENTS * (id.y * Dimension + id.x);
	int i = 0;
	NeighborsNode currentXEntry;
	do
	{
		currentXEntry = NeighborsList[offset++];
		if (currentXEntry.neighbor == -1)
		{
			TestRt[id.xy] = float4(0, 0, 0, 1);
			return;
		}
		i++;
	} while (i < TestIndex);
	TestRt[id.xy] = float4(1, 0, 0, 1);
}