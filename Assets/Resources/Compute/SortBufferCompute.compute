// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelSortDeepShadowMap

#include "../Include/DeepShadowMap.cginc"
StructuredBuffer<int> HeaderList;
StructuredBuffer<LinkedNode> LinkedList;
RWStructuredBuffer<FittingFunc> FittingFuncList;

[numthreads(8,8,1)]
void KernelSortDeepShadowMap(uint3 id : SV_DispatchThreadID)
{
	if (id.y > Dimension - 1 || id.x > Dimension - 1)
	{
		return;
	}
	int idx = id.y * Dimension + id.x;
	int num = min(HeaderList[idx], NUM_BUF_ELEMENTS);

	FittingFunc func = (FittingFunc)0;
	if (num == 0)
	{
		func.f[0] = float3(0, 1, 1);
		FittingFuncList[idx] = func;
        return;
    }

    int current = idx * NUM_BUF_ELEMENTS;;

    float depthArray[NUM_BUF_ELEMENTS];

    uint i;
    // Copy
    for (i = 0; i < NUM_BUF_ELEMENTS; i++)
    {
        depthArray[i] = LinkedList[current++].depth + 1/256.0;
    }

    float temp;
    // Sort
    uint j;
    // selection sort
    for (i = 0; i < num; i++)
    {
        uint tidx = i;
        temp = depthArray[i];
        for (j = i + 1; j < num; j++)
        {
            if (depthArray[j] < temp)
            {
				tidx = j;
                temp = depthArray[j];
            }
        }
        if (tidx != i)
        {
			depthArray[tidx] = depthArray[i];
			depthArray[i] = temp;
        }
    }

	float sumXY = 0;
	float sumX = 0;
	float sumY = 0;
	float sumXX = 0;
    float3 f[4] = func.f;

    [unroll(4)]
	for (uint k = 0; k < 4; k++)
	{
		uint n = FittingBins[k];
		for (i = 0; i < n; i++)
		{
			float x = (float)i / n;
			float y = depthArray[i];
			sumXY += x * y;
			sumX += x;
			sumY += y;
			sumXX += x * x;
		}
		float fx = (n * sumXX - sumX * sumX) / max(1E-6,(n * sumXY - sumX * sumY)); //Reciprocal
        float fy = sumY / n - sumX / fx / n;
        float fz = depthArray[FittingBinsAcc[k]];
		f[k] = float3(fx, fy, fz);
	}
    func.f = f;

	FittingFuncList[id.y * Dimension + id.x] = func;
}

