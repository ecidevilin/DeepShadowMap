// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelSortDeepShadowMap

#include "../Include/DeepShadowMap.cginc"
StructuredBuffer<int> HeaderList;
StructuredBuffer<LinkedNode> LinkedList;
RWStructuredBuffer<DoublyLinkedNode> DoublyLinkedList;

[numthreads(8,8,1)]
void KernelSortDeepShadowMap(uint3 id : SV_DispatchThreadID)
{
	if (id.y > Dimension - 1 || id.x > Dimension - 1)
	{
		return;
	}
	int idx = id.y * Dimension + id.x;
	int start = HeaderList[idx];

    int offset = idx * NUM_BUF_ELEMENTS;
	if (start == -1)
	{
        DoublyLinkedList[offset].depth = 1;
        return;
    }

    int current = start;
    int numElems = 0;
    LinkedNode node;

    int i;
    // Copy
    for (i = 0; i < NUM_BUF_ELEMENTS; i++)
    {
		if (current == -1)
		{
			DoublyLinkedList[i + offset].depth = 1;
			continue;
		}
        numElems++;
        node = LinkedList[current];
        DoublyLinkedList[i + offset].depth = node.depth + 1/256.0;
		current = node.next;
    }

    DoublyLinkedNode temp;
    // Sort
    int j;
    // selection sort
    for (i = 0; i < numElems; i++)
    {
        int idx = i;
        temp = DoublyLinkedList[idx + offset];
        for (j = i + 1; j < numElems; j++)
        {
            if (DoublyLinkedList[j + offset].depth < temp.depth)
            {
                idx = j;
                temp = DoublyLinkedList[j + offset];
            }
        }
        if (idx != i)
        {
			DoublyLinkedList[idx + offset] = DoublyLinkedList[i + offset];
			DoublyLinkedList[i + offset] = temp;
        }
    }
}

