// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel KernelSortDeepShadowMap

#include "../Include/DeepShadowMap.cginc"
StructuredBuffer<HeaderNode> HeaderList;
StructuredBuffer<LinkedNode> LinkedList;
RWStructuredBuffer<DoublyLinkedNode> DoublyLinkedList;

[numthreads(8,8,1)]
void KernelSortDeepShadowMap(uint3 id : SV_DispatchThreadID)
{
	if (id.y > Dimension - 1 || id.x > Dimension - 1)
	{
		return;
	}
	int start = HeaderList[id.y * Dimension + id.x].start;

    int offset = (id.y * Dimension + id.x) * NUM_BUF_ELEMENTS;
	if (start == -1)
	{
        DoublyLinkedList[offset].headOrTail = -1;
        return;
    }

    int current;
    current = start;
    int next = -1;
    int numElems = 0;
    LinkedNode node;

    int i;
    // Copy
    for (i = 0; i < NUM_BUF_ELEMENTS; i++)
    {
        numElems++;
        node = LinkedList[current];
        DoublyLinkedList[i + offset].depth = node.depth + 1/256.0;
        DoublyLinkedList[i + offset].shading = node.alpha;
        DoublyLinkedList[i + offset].headOrTail = 0;
        next = node.next;
        if (next == -1)
        {
            break;
        }
        current = next;
    }

    DoublyLinkedNode temp;
    // Sort
    int j;
    // insertion sort
    // for (i = 1; i < numElems; i++)
    // {
    //     temp = DoublyLinkedList[i + offset];
    //     j = i - 1;
    //     [loop]
    //     while (j >= 0 && temp.depth < DoublyLinkedList[j + offset].depth)
    //     {
    //         DoublyLinkedList[j + 1 + offset] = DoublyLinkedList[j + offset];
    //         j = j - 1;
    //     }
    //     DoublyLinkedList[j + 1 + offset] = temp;
    // }
    // selection sort
    for (i = 0; i < numElems; i++)
    {
        int idx = i;
        temp = DoublyLinkedList[idx + offset];
        for (j = i + 1; j < numElems; j++)
        {
            if (DoublyLinkedList[j + offset].depth < temp.depth)
            {
                idx = j;
                temp = DoublyLinkedList[j + offset];
            }
        }
        if (idx == i)
        {
            continue;
        }
        else
        {
            DoublyLinkedList[idx + offset] = DoublyLinkedList[i + offset];
            DoublyLinkedList[i + offset] = temp;
        }
    }

    // Shade
    float shadingBefore = 1.0;
    for (i = 0; i < numElems; i++)
    {
        float shadingCurrent = shadingBefore * (1.0 - DoublyLinkedList[i + offset].shading);
		if (shadingBefore - shadingCurrent < 0.001)
		{
            numElems = i;
			break;
		}
        shadingBefore = shadingCurrent;
		DoublyLinkedList[i + offset].shading = shadingCurrent;
    }
    DoublyLinkedList[offset].headOrTail = 1;
    DoublyLinkedList[numElems - 1 + offset].headOrTail = -1;
}

